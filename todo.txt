2021.03.19 15:31

41_ISO_IEC_9899/6_Language/5_Declarations/2_Type_specifiers/1_Structure_and_union_specifiers/1_ok/test010.c

だがこれまでは全テストの中でログが出力されず, テスト終了後に, 全テストの中で
生成された test010.exe を実行すると期待されたログが出ていたので, 放置しておいた.

しかし, 今回 g++ 版で行ったテストではテスト終了後に, 全テストの中で生成された
test010.exe を実行するとログが全く出ないという現象が再現している.

残念ながら test010.exe をデバッガから実行すると期待する動作にはなってしまう.
---------------------------------------------------------------------------
d:/home/khasegawa/GNU_LANG
で, どのプロセッサか忘れたが, cross 環境を構築できていた. そのプロセッサの
ジェネレータを作ってみたい.
----------------------------------------------------------------------------
o 5 秒以内で終わらないもの

41_ISO_IEC_9899/6_Language/1_Lexical_elements/3_Constants/4_Character_constants/1_ok/test000.c
41_ISO_IEC_9899/6_Language/1_Lexical_elements/3_Constants/4_Character_constants/1_ok/test005.c

o use_after を必ず true を返るようにしても test000.c で 6 秒費やしている.
  通常通りならば 8 - 9 秒

o 最適化なしでできるだけ複写伝播を抑えることができないか???
o テストベンチジェネレータ (学習型) なんていうのはできないか???

o generate::assigns がごちゃごちゃしている.
o warning を追加したい
  1. 参照されない変数の宣言
　　　o パラメータ
　　　o パラメータ以外のローカル変数
  2. 不定値を参照する式
  3. 参照されない static 函数, static 変数
  4. 函数からら戻り値を返さないパス
  5. スタックのアドレスを返す return
  6. セットされるが参照されない変数
----------------------------------------------------------------------------
46_optimization/test135.c
現状は pass している. 対処は refsomewhere::rvalue() で

tmp := &ref
ret := tmp + m_offset

を生成するようにした. 以前は tmp を使用しないで

ret := &ref
ret := ret + m_offset

としてた.
現在採用している dag の最適化ルーチンが

x := y op z

で y も z も x とは異なることを仮定した上で成立しているのかどうか不明.
もしそうなら, 他にもこの仮定を満たしていないコード生成の箇所がある.
(それとも単なる実装のバグなのかも不明).

追加情報 2019.04.16
hcxx1 expr00.cpp cxx_compiler::unqualified_id::from_member(usr* u)
で this ポインタからのオフセットが 0 の場合に add3ac を生成しないように
していたところ最適化ルーチンのバグが発生している.

struct S {
  int a;
  int b;
  int c;
  void f();
}; 

void S::f()
{
  a = 1;
  b = 2;
  c = 3;
}

最適化なし
	t0 := (int *)this
	t1 := (int *)this
	t1 := t1 + 4
	t2 := (int *)this
	t2 := t2 + 8
	*t0 := 1
	t3 := 1
	*t1 := 2
	t4 := 2
	*t2 := 3
	t5 := 3


最適化あり
	t0 := (int *)this
	t0 := t0 + 4
	t1 := t0 + 8
	*t0 := 1
	*t0 := 2
	*t1 := 3

refsomewhere::offref と同じような回避策を
cxx_compiler::unqualified_id::from_member(usr* u) でも行っている
refsomewhere::offref でも m_offset メンバが 0 の場合でも add3ac を
生成しているようにしているが, おそらくここが回避策の肝なのだろう.

というより..., 直せよ.
----------------------------------------------------------------------------
c.y c.l のようなものから C 言語を生成するようなツールを作れないだろうか.
----------------------------------------------------------------------------
割り込みハンドラを hcc1 と専用ジェネレータにコンパイルさせて C 言語ライクに OS を
書けないだろうか. そうすることで可読性が上がるし、今は無理でも、効率を損なうことがない
と思われる.
----------------------------------------------------------------------------
o 入力:プログラム, テストケース1
o 出力:いろいろなテストケース
こういうツールを作れないだろうか...
----------------------------------------------------------------------------
6.7.2.3 Tags
A type specifier of the form
enum identifier
without an enumerator list shall only appear after the type it specifies is completed.

とあるが、これって不完全型 enum を宣言するのはエラーだと言ってる?

struct S;   // S は不完全型構造体. ok
enum E;  // E は不完全型. error?

=> その通り. 後で C++ 4 版の教科書を読んでいたらそういうサンプルコード
   が出てきた.
