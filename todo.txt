---------------------------------------------------------------------------
extern int printf(const char*, ...);

int a = sizeof(int);

int main(void)
{
  unsigned long long int x, y, z;
  y = 0xffffffffffffff55;
  z = 4;
  x = y >> z;
  printf("%llu >> %llu = %llu\n",y,z,x);
  return 0;
}

上のプログラム sample.txt を hcc1.exe sample.txt --generator printf_chk.dll 
でコンパイルする. ここで printf_chk.dll は x86 環境で GENERAL32BIT_SETTING
を define しないでビルドする.
   ^^^^^^^^^^^^^^^

このとき generator_sizeof_type からは type::ULONG が返されるが
generator_sizeof(type::LONG) で 8 が返されるので 2 行目の sizeof(int)
に対しては, 定数 4 が

constant<unsigned __int64> で ulong_type, SUB_CONST_LONG      (1)

で作成される. 一方, z = 4 の 4 は ulogn_long_type にキャストされるので

constant<unsigned __int64> で ulong_long_type, フラグなし

で作成されるのが期待値だが (1) で作成した定数が使いまわされてしまう.
この結果, printf_chk.dll に z の型が ulong_type でわたってしまい,
エラーになっている.

同様の問題は constant<__int64> が CONST_PTR のフラグをもって作られた
場合も起こりそうだが, 再現環境は不明.

intger::create_SUB_CONST_LONG(unsigned __int64 v);

のような別バージョンの integer::create が必要になる.
---------------------------------------------------------------------------
d:/home/khasegawa/GNU_LANG
で, どのプロセッサか忘れたが, cross 環境を構築できていた. そのプロセッサの
ジェネレータを作ってみたい.
----------------------------------------------------------------------------
o 5 秒以内で終わらないもの

41_ISO_IEC_9899/6_Language/1_Lexical_elements/3_Constants/4_Character_constants/1_ok/test000.c
41_ISO_IEC_9899/6_Language/1_Lexical_elements/3_Constants/4_Character_constants/1_ok/test005.c

o use_after を必ず true を返るようにしても test000.c で 6 秒費やしている.
  通常通りならば 8 - 9 秒

o 最適化なしでできるだけ複写伝播を抑えることができないか???
o テストベンチジェネレータ (学習型) なんていうのはできないか???

o generate::assigns がごちゃごちゃしている.
o warning を追加したい
  1. 参照されない変数の宣言
　　　o パラメータ
　　　o パラメータ以外のローカル変数
  2. 不定値を参照する式
  3. 参照されない static 函数, static 変数
  4. 函数からら戻り値を返さないパス
  5. スタックのアドレスを返す return
  6. セットされるが参照されない変数
----------------------------------------------------------------------------
46_optimization/test135.c
現状は pass している. 対処は refsomewhere::rvalue() で

tmp := &ref
ret := tmp + m_offset

を生成するようにした. 以前は tmp を使用しないで

ret := &ref
ret := ret + m_offset

としてた.
現在採用している dag の最適化ルーチンが

x := y op z

で y も z も x とは異なることを仮定した上で成立しているのかどうか不明.
もしそうなら, 他にもこの仮定を満たしていないコード生成の箇所がある.
(それとも単なる実装のバグなのかも不明).

追加情報 2019.04.16
hcxx1 expr00.cpp cxx_compiler::unqualified_id::from_member(usr* u)
で this ポインタからのオフセットが 0 の場合に add3ac を生成しないように
していたところ最適化ルーチンのバグが発生している.

struct S {
  int a;
  int b;
  int c;
  void f();
}; 

void S::f()
{
  a = 1;
  b = 2;
  c = 3;
}

最適化なし
	t0 := (int *)this
	t1 := (int *)this
	t1 := t1 + 4
	t2 := (int *)this
	t2 := t2 + 8
	*t0 := 1
	t3 := 1
	*t1 := 2
	t4 := 2
	*t2 := 3
	t5 := 3


最適化あり
	t0 := (int *)this
	t0 := t0 + 4
	t1 := t0 + 8
	*t0 := 1
	*t0 := 2
	*t1 := 3

refsomewhere::offref と同じような回避策を
cxx_compiler::unqualified_id::from_member(usr* u) でも行っている
refsomewhere::offref でも m_offset メンバが 0 の場合でも add3ac を
生成しているようにしているが, おそらくここが回避策の肝なのだろう.

というより..., 直せよ.
----------------------------------------------------------------------------
int x, y;
...
x = 定数1;
y = 定数2;
if (x == y) {
  ...
}
現状これが最適化されていない.
----------------------------------------------------------------------------
c.y c.l のようなものから C 言語を生成するようなツールを作れないだろうか.
----------------------------------------------------------------------------
割り込みハンドラを hcc1 と専用ジェネレータにコンパイルさせて C 言語ライクに OS を
書けないだろうか. そうすることで可読性が上がるし、今は無理でも、効率を損なうことがない
と思われる.
----------------------------------------------------------------------------
o 入力:プログラム, テストケース1
o 出力:いろいろなテストケース
こういうツールを作れないだろうか...
----------------------------------------------------------------------------
6.7.2.3 Tags
A type specifier of the form
enum identifier
without an enumerator list shall only appear after the type it specifies is completed.

とあるが、これって不完全型 enum を宣言するのはエラーだと言ってる?

struct S;   // S は不完全型構造体. ok
enum E;  // E は不完全型. error?


